import json
from bson import ObjectId
from pvutils.utils import (
    get_boundary,
    get_user,
    InvalidFieldsException,
    InvalidPaginationException,
    InvalidSortException,
    MethodNotAllowedException,
    ResourceNotFoundException,
    UserException,
    UtilsAPI
)

class API(UtilsAPI):
    def __init__(self, model=None, event=None):
        self.model = model
        self.event = event
        self.user = get_user(event)
        if not self.user:
            raise UserException("Invalid user")
        self.model.user = self.user

    def handle_request(self):
        _id = None
        if self.event["pathParameters"]:
            parameter_id = self.model.get_id_field()
            _id = self.event["pathParameters"].get(parameter_id)
        if self.event["httpMethod"] == "GET":
            if not _id:
                query_params = {}
                if isinstance(self.event["queryStringParameters"], dict):
                    query_params = self.event["queryStringParameters"]
                return self.load(**query_params)
            else:
                return self.load_one(_id=_id)
        elif self.event["httpMethod"] == "POST":
            data = self.event["body"]
            return self.create(data=data)
        elif self.event["httpMethod"] == "PUT":
            criteria = None
            if not _id:
                if isinstance(self.event["queryStringParameters"], dict):
                    criteria = json.loads(self.event["queryStringParameters"].get("query", '{}'))
            else:
                criteria = {"_id": _id}
            data = self.event["body"]
            return self.update(criteria, data=data)

        elif self.event["httpMethod"] == "DELETE":
            return self.delete(criteria={"_id": _id})
        else:
            raise MethodNotAllowedException("Method not allowed")

    def __get_pagination(self, page, per_page):
        try:
            page = int(page)
            per_page = int(per_page)
            per_page = per_page if per_page <= 100 else 100
            skip = per_page * (page - 1)
            return (page, per_page, skip)
        except:
            raise InvalidPaginationException("Pagination is not valid")

    def __get_fields(self, fields):
        try:
            if fields:
                project = {}
                for field in fields.split(","):
                    if field:
                        project[field] = True
                return project
            return None
        except:
            raise InvalidFieldsException("Invalid fields structure")

    def __get_sort(self, sort):
        try:
            sort_order = {}
            if sort:
                fields = sort.split(",")
                for field in fields:
                    if field.startswith("+"):
                        sort_order[field.replace("+", "")] = 1
                    else:
                        sort_order[field.replace("-", "")] = -1
            return sort_order
        except:
            raise InvalidSortException("Invalid sort")

    def load(self, **kwargs):
        """
        # https://stackoverflow.com/questions/49605748/how-can-we-skip-recoards-in-mongodb-stitch
        # mongo stitch not support skip in find command. Temp workaround

        load collection registers
        :param query:
        :param page:
        :param per_page:
        """
        try:
            # self.__check_permissions()
            per_page = kwargs.get("per_page", 100)
            page = kwargs.get("page", 1)
            fields = kwargs.get("fields")
            sort = kwargs.get("sort")
            raw_query = kwargs.get("query")
            page, per_page, skip = self.__get_pagination(page, per_page)
            fields = self.__get_fields(fields)
            sort = self.__get_sort(sort)
            query = self.get_query(raw_query)
            total, entities = self.model.load(query=query, raw_query=raw_query,
                                       fields=fields, sort=sort, skip=skip,
                                       per_page=per_page)
            next_page = None
            prev_page = None
            if (page * per_page) < total:
                next_page = page + 1
            if page > 1:
                prev_page = page - 1
            return self.success_response(
                status_code=200,
                data={
                    "count": total,
                    "result": entities,
                    "next_page": next_page,
                    "prev_page": prev_page,
                },
            )
        except:
            raise

    def load_one(self, _id, **kwargs):
        try:
            # self.__check_permissions()
            fields = kwargs.get("fields")
            query = {"_id": ObjectId(_id)}
            get_boundary(self.user, query)
            entity = self.model.load_one(query=query, fields=fields)
            return self.success_response(status_code=200, data={"result": entity})
        except:
            raise

    def create(self, data=None):
        try:
            # self.__check_permissions()
            data = json.loads(data)
            entity = self.model.create(data)
            return self.success_response(
                status_code=201, data={"result": entity}
            )
        except:
            raise

    def update(self, criteria=None, data=None):
        try:
            # self.__check_permissions()
            if "_id" in criteria:
                criteria["_id"] = ObjectId(criteria["_id"])
            get_boundary(self.user, criteria)
            data = json.loads(data)
            entity = self.model.update(query=criteria, data=data)
            return self.success_response(
                status_code=200, data={"result": entity}
            )
        except:
            raise

    def delete(self, criteria, logic=False):
        # if logic is true, the status will be changed to status deleted
        try:
            # self.__check_permissions()
            if "_id" in criteria:
                criteria["_id"] = ObjectId(criteria["_id"])
            get_boundary(self.user, criteria)
            self.model.delete(criteria=criteria, logic=logic)
            return self.success_response(status_code=200)
        except:
            raise
