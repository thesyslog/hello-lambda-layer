from abc import ABC, abstractmethod
from datetime import datetime
from cerberus import Validator
import bleach
from bson import ObjectId
from pvutils.utils import (
    InvalidSchemaException,
    DBException,
    ResourceNotFoundException,
    fill_mandatory_fields,
)
import re


def validate_objectid(field, value, error):
    if not ObjectId.is_valid(value):
        error(field, "ObjectId is not valid")


def validate_url_field(field, value, error):
    regex = re.compile(
        r"^(?:http|ftp)s?://"  # http:// or https://
        r"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|"  # domain...
        r"localhost"  # localhost...
        r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"  # ...or ip
        r"(?::\d+)?"  # optional port
        r"(?:/?|[/?]\S+)$",
        re.IGNORECASE,
    )
    if not regex.match(value):
        error(field, "Url is not valid")


class Model(ABC):
    def __init__(self, db=None, collection=None):
        self.__user = None
        self.db = db
        self.collection = collection

    @property
    def user(self):
        return self.__user

    @user.setter
    def user(self, value):
        self.__user = value

    @abstractmethod
    def get_schema(self):
        pass

    def get_parent_id_field(self):
        return "_id"

    def get_id_field(self):
        return "_id"

    def get_custom_sanitize(self):
        return {}

    def count(self, query):
        return self.db[self.collection].count_documents(query)

    # load
    def load(
        self,
        query=None,
        raw_query=None,
        fields=None,
        sort=None,
        skip=None,
        per_page=None,
    ):
        query, fields, sort = self.before_load(
            query=query, raw_query=raw_query, fields=fields, sort=sort
        )
        pipeline = [{"$match": query}]
        if sort:
            pipeline.append({"$sort": sort})
        pipeline.append({"$skip": skip})
        pipeline.append({"$limit": per_page})
        if fields:
            pipeline.append({"$project": fields})
        entities = self.db[self.collection].aggregate(pipeline)
        total = self.count(query)
        return (total, list(self.on_load(entities)))

    def before_load(self, query=None, raw_query=None, fields=None, sort=None):
        if not sort:
            sort = {"created_at": -1}
        return (query, fields, sort)

    def on_load(self, data):
        return data

    # load one
    def load_one(self, query, fields):
        query, fields = self.before_load_one(query=query, fields=fields)
        entity = self.db[self.collection].find_one(query, projection=fields)
        if entity:
            self.on_load_one(entity)
            return entity
        else:
            raise ResourceNotFoundException("Resource not found")

    def before_load_one(self, query={}, fields=None):
        return (query, fields)

    def on_load_one(self, result):
        pass

    # crete
    def create(self, data=None, default_fields=True):
        self.before_create(data=data)
        data = self.validate_schema(data, self.get_schema())
        if default_fields:
            now = datetime.utcnow()
            data.update(
                {"created_at": now, "updated_at": now, "created_by": self.user["_id"]}
            )
            fill_mandatory_fields(self.user, data)
        self.sanitize(data=data, setup=self.get_custom_sanitize())
        _id = self.db[self.collection].insert_one(data).inserted_id
        if _id:
            entity = self.db[self.collection].find_one({"_id": _id})
            return self.on_create(entity=entity)
        else:
            raise DBException("Unable to save")

    def before_create(self, entity=None, data=None):
        """
        entity: applies for embed
        """
        pass

    def on_create(self, entity=None):
        return entity

    # update
    def update(self, query=None, data=None):
        self.before_update_set_query(query)
        entity = self.db[self.collection].find_one(query)
        if entity:
            self.before_update(entity=entity, data=data)
            self.validate_schema(data, self.get_schema(update=True), update=True)
            data["updated_at"] = datetime.utcnow()
            self.sanitize(data=data, setup=self.get_custom_sanitize())
            response = self.db[self.collection].update_one(query, {"$set": data})
            if response.matched_count:
                entity = self.db[self.collection].find_one(query)
                return self.on_update(entity)
            else:
                raise DBException("Unable to update")
        else:
            raise ResourceNotFoundException("Resource not found")

    def before_update_set_query(self, query):
        """
        set the initial criteria before update
        """
        pass

    def before_update(self, _id=None, entity=None, data=None):
        """
        entity applies for root and embed
        """
        pass

    def on_update(self, entity):
        return entity

    # delete
    def delete(self, criteria=None, logic=False):
        self.before_delete_set_criteria(criteria)
        entity = self.db[self.collection].find_one(criteria)
        if entity:
            self.before_delete(entity=entity, criteria=criteria)
            if logic:
                response = self.db[self.collection].update_one(
                    criteria,
                    {"$set": {"status": "deleted", "updated_at": datetime.utcnow(),}},
                )
                if response.matched_count:
                    self.on_delete(entity=entity)
                else:
                    raise DBException("Unable to delete")
            else:
                response = self.db[self.collection].delete_one(criteria)
                if response.deleted_count:
                    self.on_delete(entity=entity)
                else:
                    raise DBException("Unable to delete")
        else:
            raise ResourceNotFoundException("Resource not found")

    def before_delete_set_criteria(self, criteria=None):
        """
        set the initial criteria before delete
        """
        pass

    def before_delete(self, entity=None, criteria=None):
        """"""
        pass

    def on_delete(self, entity=None):
        """
        entity applies for root and embed
        """
        pass

    def validate_schema(self, data, schema, update=False):
        v = Validator()
        result = v.validated(data, schema, update=update)
        if result:
            return result
        raise InvalidSchemaException(str(v.errors))

    def sanitize(self, data=None, setup={}):
        """
        params: setup
        example:

        setup: {
            "tags": ["p"],
            "attributes": "data-image",
            "styles": ["background-color"]
        }
        """
        if isinstance(data, list):
            for i, item in enumerate(data):
                if isinstance(item, str):
                    data[i] = bleach.clean(item, **setup).replace("&amp;", "&")
                else:
                    self.sanitize(item, setup)
        elif isinstance(data, dict):
            for key in data:
                if isinstance(data[key], str):
                    data[key] = bleach.clean(data[key], **setup).replace("&amp;", "&")
                else:
                    self.sanitize(data[key], setup)

    # Embebeb
    def __get_path(self, obj, path, result=None):
        if not result:
            result = []
        if path:
            p = path.pop(0)
            if p["field"] in obj:
                if p["value"] is None:
                    result.append(p["field"])
                    return result
                for index, item in enumerate(obj[p["field"]]):
                    if item[p["sub_field"]] == p["value"]:
                        result.append(p["field"])
                        result.append(str(index))
                        return self.__get_path(obj[p["field"]][index], path, result)
        else:
            return result

    def create_embed(self, query=None, data=None, path=None):
        entity = self.db[self.collection].find_one(query)
        if entity:
            self.before_create(entity=entity, data=data)
            data = self.validate_schema(data, self.get_schema())
            self.sanitize(data=data, setup=self.get_custom_sanitize())
            result = self.__get_path(entity, path)
            response = None
            if result:
                embed_field = ".".join(result)
                response = self.db[self.collection].update_one(
                    query,
                    {
                        "$push": {embed_field: data},
                        "$set": {"updated_at": datetime.utcnow()},
                    },
                )
            if response and response.matched_count:
                entity = self.db[self.collection].find_one(query)
                # Should return the entire doc or only the object
                entity = self.on_create(entity=entity)
                return entity
            else:
                raise DBException("Unable to update")
        else:
            raise ResourceNotFoundException("Resource not found")

    def update_embed(self, query=None, data=None, path=None):
        entity = self.db[self.collection].find_one(query)
        if entity:
            sub_field_id = path[-1]["value"]
            self.before_update(_id=sub_field_id, entity=entity, data=data)
            self.validate_schema(data, self.get_schema(update=True), update=True)
            self.sanitize(data=data, setup=self.get_custom_sanitize())
            result = self.__get_path(entity, path)
            response = None
            # check if last level embed document has value
            if not result or not sub_field_id:
                raise ResourceNotFoundException("Resource not found")
            else:
                embed_field = ".".join(result)
                set_data = {"updated_at": datetime.utcnow()}
                for key in data:
                    set_data[embed_field + "." + key] = data[key]
                response = self.db[self.collection].update_one(
                    query, {"$set": set_data}
                )
            if response and response.matched_count:
                entity = self.db[self.collection].find_one(query)
                return self.on_update(entity)
            else:
                raise DBException("Unable to update")
        else:
            raise ResourceNotFoundException("Resource not found")

    def delete_embed(self, criteria=None, data=None, path=None):
        entity = self.db[self.collection].find_one(criteria)
        if entity:
            self.before_delete(entity=entity, criteria=criteria)
            sub_criteria = {path[-1]["sub_field"]: path[-1]["value"]}
            result = self.__get_path(entity, path)
            response = None
            if not result:
                raise ResourceNotFoundException("Resource not found")
            else:
                del result[-1]
                embed_field = ".".join(result)
                response = self.db[self.collection].update_one(
                    criteria,
                    {
                        "$pull": {embed_field: sub_criteria},
                        "$set": {"updated_at": datetime.utcnow()},
                    },
                )
            if response and response.matched_count:
                entity = self.db[self.collection].find_one(criteria)
                self.on_delete(entity=entity)
                return entity
            else:
                raise DBException("Unable to update")
        else:
            raise ResourceNotFoundException("Resource not found")
