import json
import logging
import re
from bson import ObjectId
from bson.errors import InvalidId
from datetime import datetime
from pvutils import config
from cerberus import Validator


# TODO:
# Define a method to validate permissions
# Define the errors structure and codes
# Stitch limitations https://docs.mongodb.com/stitch/mongodb/mongodb-service-limitations/


class InsufficientPermissionsException(Exception):
    pass


class InvalidSchemaException(Exception):
    pass


class ResourceNotFoundException(Exception):
    pass


class UnknowErrorException(Exception):
    pass


class DBException(Exception):
    pass


class MethodNotAllowedException(Exception):
    pass


class MissingParentIdException(Exception):
    pass


class InvalidPaginationException(Exception):
    pass


class InvalidFieldsException(Exception):
    pass


class InvalidSortException(Exception):
    pass


class InvalidQueryException(Exception):
    pass


class UserException(Exception):
    pass


class DuplicateCommentAttachmentUrlException(Exception):
    pass


class GeneralBadRequestException(Exception):
    pass


class ConflictException(Exception):
    pass


def get_user(event):
    if event.get("requestContext", {}).get("authorizer"):
        if config.AUTHORIZER == "cognito":
            user = json.loads(event["requestContext"]["authorizer"]["claims"].get("user"))
        else:
            user = json.loads(event["requestContext"]["authorizer"].get("user"))
        for field_id in config.OID_USER_FIELDS:
            user[field_id] = ObjectId(user[field_id])
        return user
    return None


def get_boundary(user, data):
    for field_id in config.BOUNDARIES:
        data[field_id] = user[field_id]


def fill_mandatory_fields(user, data):
    for field_id in config.MANDATORY_FIELDS:
        data[field_id] = user[field_id]


class JSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, ObjectId):
            return str(o)
        if isinstance(o, datetime):
            return o.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        return json.JSONEncoder.default(self, o)


class UtilsAPI:
    def __check_permissions(self):
        raise InsufficientPermissionsException("Permission denied")

    def validate_schema(self, data, schema, update=False):
        v = Validator()
        result = v.validated(data, schema, update=update)
        if result:
            return result
        raise InvalidSchemaException(str(v.errors))

    def handle_response(self, exception):
        if isinstance(exception, ResourceNotFoundException):
            status_code = 404
            error = {
                "message": "Resource not found",
                "code": "resource_not_found",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidId):
            status_code = 400
            error = {
                "message": "Invalid id",
                "code": "invalid_id",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidSchemaException):
            status_code = 400
            error = {
                "message": "Invalid data",
                "code": "invalid_payload",
                "details": str(exception),
            }
        elif isinstance(exception, GeneralBadRequestException):
            status_code = 400
            error = {
                "message": "Bad request",
                "code": "bad_request",
                "details": str(exception),
            }
        elif isinstance(exception, MethodNotAllowedException):
            status_code = 405
            error = {
                "message": "Method not allowed",
                "code": "method_not_allowed",
                "details": str(exception),
            }
        elif isinstance(exception, MissingParentIdException):
            status_code = 400
            error = {
                "message": "Missing id in the resource url",
                "code": "parent_id_required",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidPaginationException):
            status_code = 400
            error = {
                "message": "Pagination is not valid",
                "code": "invalid_pagination",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidFieldsException):
            status_code = 400
            error = {
                "message": "Invalid fields",
                "code": "invalid_fields",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidSortException):
            status_code = 400
            error = {
                "message": "Invalid sort",
                "code": "invalid_sort",
                "details": str(exception),
            }
        elif isinstance(exception, InvalidQueryException):
            status_code = 400
            error = {
                "message": "Invalid query",
                "code": "invalid_query",
                "details": str(exception),
            }
        elif isinstance(exception, UserException):
            status_code = 400
            error = {"message": "Invalid user", "code": "invalid_user"}
        elif isinstance(exception, DBException):
            status_code = 500
            error = {"message": "Unknown error (DB)", "code": "unknown_error"}
        elif isinstance(exception, ConflictException):
            status_code = 409
            error = {
                "message": "Conflict exception",
                "code": "conflict",
                "details": str(exception),
            }
        elif isinstance(exception, DuplicateCommentAttachmentUrlException):
            status_code = 400
            error = {
                "message": "Comment has duplicated urls in his attachments",
                "code": "duplicated_attachment_url",
                "details": str(exception),
            }
        else:
            status_code = 500
            error = {
                "message": "Unknown error",
                "code": "unknown_error",
                "details": str(exception),
            }

        return self.error_response(status_code=status_code, error=error)

    def str_to_datetime(self, str_date=None, key=None):
        """This method get query to convert dates values from string to datetime format.

        :param: key (str) key url params query
        :param: str_date (str) date or datetime in string format
        :return: (datetime) parse dates
        """
        try:
            if re.search(r"\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ", str_date):
                date = self.get_iso_date(date=str_date, adjust=False)
            elif re.search(r"\d\d\d\d-\d\d-\d\d", str_date):
                if key and key in ["$lt", "$gte", "$eq", "$ne", "start_date"]:
                    date = self.get_iso_date(date=str_date)
                elif key and key in ["$gt", "$lte", "end_date"]:
                    date = self.get_iso_date(date=str_date, end=True)
                else:
                    date = datetime.strptime(str_date, "%Y-%m-%d")
            return date
        except:
            pass
        return None

    def get_iso_date(self, date=None, end=False, adjust=True):
        try:
            if not end:
                if adjust:
                    date = date + "T00:00:00Z"
                return datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ")
            else:
                if adjust:
                    date = date + "T23:59:59Z"
                return datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ")
        except ValueError as e:
            self.custom_logging(message="error get iso date format", type_="error", exception=e)
            return None

    @staticmethod
    def unescape_url(url):
        return url.replace("&amp;", "&")

    @staticmethod
    def custom_logging(feature=None, message=None, type_="error", exception=None, extra={}):
        """
        how to use:
        UtilsAPI.custom_logging(
            feature="export-center", message="Unable to export file", type_="error")
        :param feature: feature name, example: workloads
        :param type_: logging type info info, warning or error
        :param exception: (Exception): Exception related to the error
        :param extra: dict extra params to get more insights
        :returns: return the log message concatenated
        :raises: Exception if type_ is not valid
        """
        try:
            log = f"feature:{feature},message:{message},extra:{extra}"
            if type_ == "info":
                logging.info(log)
            elif type_ == "warning":
                logging.warning(log)
            elif type_ == "error":
                if exception:
                    log = f"{log} {exception}"
                    if not isinstance(extra, dict):
                        extra = {}
                    extra = {"data": str(extra)}
                    logging.error(log, exc_info=True, extra=extra)
                else:
                    logging.error(log)
            else:
                raise Exception(f"Invalid logging type {type_}")
        except Exception as e:
            log = f"custom_logging error type_ {e} is not valid"
            logging.error(log)
        return log

    def cast_object_ids(self, value):
        if isinstance(value, list):
            nlist = []
            for element in value:
                if ObjectId.is_valid(element):
                    nlist.append(ObjectId(element))
                else:
                    nlist.append(element)
            return nlist
        elif isinstance(value, str) and ObjectId.is_valid(value):
            return ObjectId(value)
        else:
            return value

    def parse_query(self, query={}, cast_ids=True):
        try:
            for k, v in query.items():
                if isinstance(v, dict):
                    self.parse_query(v, cast_ids)
                elif isinstance(v, list):
                    for element in v:
                        if isinstance(element, dict):
                            self.parse_query(element, cast_ids)
                        elif cast_ids:
                            query[k] = self.cast_object_ids(v)
                elif self.str_to_datetime(v, k):
                    query[k] = self.str_to_datetime(v, k)
                elif cast_ids:
                    query[k] = self.cast_object_ids(v)
        except:
            raise

    def success_response(self, status_code=200, data={}):
        """
        example response for lambda
        {
            "statusCode": 200,
            "body": json.dumps(response)
        }
        """
        body = {"success": True, **data}
        if "result" in body:
            body["result"] = json.loads(JSONEncoder().encode(body["result"]))
        response = {"statusCode": status_code, "body": json.dumps(body)}
        if config.HEADERS:
            response.update({"headers": config.HEADERS})
        return response

    def error_response(self, status_code=500, error={}):
        body = {"success": False, "error": error}
        response = {"statusCode": status_code, "body": json.dumps(body)}
        if config.HEADERS:
            response.update({"headers": config.HEADERS})
        return response

    def get_query(self, query):
        try:
            if not query:
                query = {}
            else:
                query = json.loads(query)
            if "$where" in query:
                raise InvalidQueryException("Invalid query")
            else:
                get_boundary(self.user, query)
                self.parse_query(query)
                return query
        except:
            raise InvalidQueryException("Invalid query")
